#!/bin/bash
set -e

cmd="$1"
app="strongbox-catalogue-builder"

if test ! "$cmd"; then
    echo "command required."
    echo
    echo "available commands:"
    # alphabetical order
    echo "  build               build project"
    echo "  build.all           build project, ignore cache"
    echo "  build.release       build project for distribution"
    echo "  clean               deletes all generated files"
    echo "  deps.update         update project dependencies"
    echo "  test                run project tests"
    echo "  test.coverage [N]   run tests with coverage report (default threshold: 80%)"
    echo "  test.coverage.show  show coverage report without threshold check"
    echo "  test.verbose        run tests with verbose output"
    exit 1
fi

shift
rest=$*

if test "$cmd" = "build"; then
    ./manage.sh clean
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # -v 'verbose'
    CGO_ENABLED=0 go build \
        -v \
        -o "$app"
    echo "wrote $app"
    exit 0

elif test "$cmd" = "build.all"; then
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # -a 'build all'
    # -v 'verbose'
    ./manage.sh clean
    CGO_ENABLED=0 go build \
        -a \
        -v \
        -o "$app"
    echo "wrote $app"
    exit 0

elif test "$cmd" = "build.release"; then
    # GOOS is 'Go OS' and is being explicit in which OS to build for.
    # CGO_ENABLED=0 skips CGO and linking against glibc to build static binaries.
    # ld -s is 'disable symbol table'
    # ld -w is 'disable DWARF generation'
    # -trimpath removes leading paths to source files
    # -v 'verbose'
    # -o 'output'
    set -u
    version="$1" # 1.0.0
    GOOS=linux GOARCH=amd64 CGO_ENABLED=0 go build \
        -ldflags "-s -w -X main.APP_VERSION=$version" \
        -trimpath \
        -v \
        -o linux-amd64
    if command -v upx &> /dev/null; then
        upx linux-amd64
    fi
    sha256sum linux-amd64 > linux-amd64.sha256

    GOOS=linux GOARCH=arm64 CGO_ENABLED=0 go build \
        -ldflags "-s -w -X main.APP_VERSION=$version" \
        -trimpath \
        -v \
        -o linux-arm64
    if command -v upx &> /dev/null; then
        upx linux-arm64
    fi
    sha256sum linux-arm64 > linux-arm64.sha256
    echo ---
    go version
    echo ---
    if command -v upx &> /dev/null; then
        upx --version
    else
        echo "upx not found (optional for compression)"
    fi
    echo ---
    du -sh linux-a*
    echo ---
    echo "done"
    exit 0

elif test "$cmd" = "clean"; then
    # -f 'force' don't fail if file doesn't exist.
    # -v 'verbose' print the name of the file that was deleted.
    tbd=(
        "main" "$app" # generated by 'build'
        "linux-amd64" "linux-amd64.sha256" "linux-arm64" "linux-arm64.sha256" # generated by 'release'
        "cache" # cache directory
        "*.json" # output files
    )
    rm -rfv ${tbd[@]} 2>/dev/null || true
    exit 0

elif test "$cmd" = "deps.update"; then
    # -u 'update modules [...] to use newer minor or patch releases when available'
    go get -u
    go mod tidy
    ./manage.sh build
    exit 0

elif test "$cmd" = "test"; then
    # Run tests in all packages under src/
    go test ./src/...
    exit 0

elif test "$cmd" = "test.coverage"; then
    # Coverage threshold (can be overridden with argument)
    threshold=${1:-80}  # Default 80% coverage required

    echo "Running tests with coverage (threshold: ${threshold}%)..."

    # Run tests with coverage profile
    go test -coverprofile=coverage.out ./src/... || {
        echo "Tests failed"
        exit 1
    }

    # Extract overall coverage percentage
    coverage=$(go tool cover -func=coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')

    echo
    echo "=== Coverage Report ==="
    go tool cover -func=coverage.out
    echo
    echo "Overall coverage: ${coverage}%"
    echo "Required threshold: ${threshold}%"

    # Generate HTML report
    go tool cover -html=coverage.out -o coverage.html
    echo "Detailed HTML report: coverage.html"

    # Check threshold
    if (( $(echo "$coverage >= $threshold" | bc -l) )); then
        echo "✅ Coverage threshold met (${coverage}% >= ${threshold}%)"
        exit 0
    else
        echo "❌ Coverage below threshold (${coverage}% < ${threshold}%)"
        echo
        echo "To improve coverage, add tests for uncovered code."
        echo "View coverage.html in a browser to see which lines need coverage."
        exit 1
    fi

elif test "$cmd" = "test.coverage.show"; then
    echo "Running tests with coverage (informational only)..."

    # Run tests with coverage profile
    go test -coverprofile=coverage.out ./src/... || {
        echo "Tests failed"
        exit 1
    }

    # Extract overall coverage percentage
    coverage=$(go tool cover -func=coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')

    echo
    echo "=== Coverage Report ==="
    go tool cover -func=coverage.out
    echo
    echo "Overall coverage: ${coverage}%"

    # Generate HTML report
    go tool cover -html=coverage.out -o coverage.html
    echo "Detailed HTML report: coverage.html"
    echo
    echo "ℹ️  This is informational only. Use 'test.coverage [N]' to enforce thresholds."
    exit 0

elif test "$cmd" = "test.verbose"; then
    # Run tests with verbose output
    go test -v ./src/...
    exit 0

# ...

fi

echo "unknown command: $cmd"
exit 1